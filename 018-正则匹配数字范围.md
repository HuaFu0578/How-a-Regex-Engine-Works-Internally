## 1. 正则匹配数字范围
正则表达式是为了匹配字符而设计的，而并不是为了匹配数字，所以当你使用正则匹配指定范围内的数字的时候你需要额外小心。表达式`[0-255]`并不能匹配0至255之间的数字。表达式`[0-255]`是一个[字符集](https://github.com/SBDavid/How-a-Regex-Engine-Works-Internally/blob/master/005-%E5%AD%97%E7%AC%A6%E7%B1%BB.md)，它的含义是匹配 0，1，2，5中任意一个字符，这个表达式等同于`[0125]`。

正则引擎真正处理的是字符，所以数字0对于引擎来说是一个字符，而255对于引擎来说是长度为3的字符。所以如何要匹配0至255中的所有数字，我们需要让引擎匹配长度为一到三之间的字符。

表达式`[0-9]`可以匹配0~9之间的数字。`[1-9][0-9]`可以匹配10~99之间的数字。这两个是最简单的。

匹配三位整数略微复杂一点，因为我们要排除256至999之间的整数。`1[0-9][0-9]`可以匹配100至199。`2[0-4][0-9]`匹配200至249。最后`25[0-5]`匹配250至255。

你可以发现当我们匹配0到255之间的整数时，我们需要按照字符的长度来分割这个范围。在匹配三位整数的时候，如果百位是 1 ，那么十位和个位允许出现 0 至 9 之间的10个字符，如果百位是 2 ，那么十位和个位的字符将进一步做限制。

把前面三个部分用[选择符](https://github.com/SBDavid/How-a-Regex-Engine-Works-Internally/blob/master/010-%E9%80%89%E6%8B%A9%E7%AC%A6.md)连接起来，我们就得到了0只255之间所有的整数：`[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]`。这个方法还存在一个缺陷：正则表达式通常允许部分匹配，所以这个表达式可以匹配到 12345 中的 123。有两个方法可以解决这个问题。

## 2. 搜索指定长度的字符
如果你在一个文档中所搜数字，你可以使用[词语边界](https://github.com/SBDavid/How-a-Regex-Engine-Works-Internally/blob/master/009-%E8%AF%8D%E8%AF%AD%E8%BE%B9%E7%95%8C.md)锁定数字的范围：`\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b`。因为选择符的优先级是最低的，所以我们要在选择外加上括号。这样引擎会先匹配第一个边界符`\b`，然后匹配整个选择符，最后匹配最后一个`\b`。

## 3. 验证指定长度的字符
如果你想验证用户输入内容，那么或许你想验证的是用户输入的完整内容，而不是其中的部分。你可以使用[位置字符](https://github.com/SBDavid/How-a-Regex-Engine-Works-Internally/blob/master/008-%E4%BD%8D%E7%BD%AE%E5%AD%97%E7%AC%A6.md)：`^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$`。

以下一些常用的数字匹配。

- 000..255: `^([01][0-9][0-9]|2[0-4][0-9]|25[0-5])$`
- 0 or 000..255: `^([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$`
- 0 or 000..127: `^(0?[0-9]?[0-9]|1[01][0-9]|12[0-7])$`
- 0..999: `^([0-9]|[1-9][0-9]|[1-9][0-9][0-9])$`
- 000..999: `^[0-9]{3}$`
- 0 or 000..999: `^[0-9]{1,3}$`
- 1..999: `^([1-9]|[1-9][0-9]|[1-9][0-9][0-9])$`
- 001..999: `^(00[1-9]|0[1-9][0-9]|[1-9][0-9][0-9])$`
- 1 or 001..999: `^(0{0,2}[1-9]|0?[1-9][0-9]|[1-9][0-9][0-9])$`
- 0 or 00..59: `^[0-5]?[0-9]$`
- 0 or 000..366: `^(0?[0-9]?[0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$`